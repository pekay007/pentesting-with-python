import multiprocessing as mp
import os
import subprocess
import threading
from time import sleep

import psutil
import requests
from stem import Signal
from stem.control import Controller


def banner():
    bnrstr = """

thelonewolf123
___________                                               ___.             ___ ___  __    
\\__    ___/__________  _____________  _______  ______.__. \\_ |__ ___.__.  /   |   \\|  | __
  |    | /  _ \\_  __ \\ \\____ \\_  __ \\/  _ \\  \\/  <   |  |  | __ <   |  | /    ~    \\  |/ /
  |    |(  <_> )  | \\/ |  |_> >  | \\(  <_> >    < \\___  |  | \\_\\ \\___  | \\    Y    /    < 
  |____| \\____/|__|    |   __/|__|   \\____/__/\\_ \\/ ____|  |___  / ____|  \\___|_  /|__|_ \\
                       |__|                     \\/\\/           \\/\\/             \\/      \\/	
"""
    print(bnrstr)


def killtree(pid, including_parent=True):
    parent = psutil.Process(pid)
    for child in parent.children(recursive=True):
        print("child", child)
        child.kill()

    if including_parent:
        parent.kill()


class IProtator(mp.Process):

    def __init__(self, url, method, thread_lmt, response_handler, sleep_time=10, headers={}, rotateIP=True, ctrlPort=9051, torPort=9050, torrcPath='/etc/tor/torrc'):
        mp.Process.__init__(self)
        self.url = url
        self.method = method.upper()
        self.thread_lmt = thread_lmt
        self.response_handler = response_handler
        self.sleep_time = sleep_time
        self.headers = headers
        self.rotateIP = rotateIP
        self.ctrlPort = ctrlPort
        self.torPort = torPort
        self.torrcPath = torrcPath
        # banner()

    def run(self):
        if self.torrcPath != '/etc/tor/torrc':
            print('Initializing tor')
            self.initTor()
        self.thread_handler()

    def thread_handler(self):

        threads = []
        argumets = []
        count = 0

        for urld, data in self.url:

            count += 1
            if len(data) == 0:
                argumets = [urld, self.method, self.headers]
            else:
                argumets = [urld, self.method, self.headers, data]

            thread = threading.Thread(target=self.try_request, args=argumets)
            thread.start()
            threads.append(thread)

            if count % self.thread_lmt == 0:

                for thread in threads:
                    thread.join()
                if self.rotateIP:
                    sleep(self.sleep_time)
                    self.changeIP()

                threads.clear()

        for thread in threads:
            thread.join()

    def try_request(self, url, method, headers, payload={}):

        proxies = {}
        proxies["http"] = f"socks5h://localhost:{self.torPort}"
        proxies["https"] = f"socks5h://localhost:{self.torPort}"

        try:
            res = requests.request(
                method, url, data=payload, proxies=proxies, headers=headers)
        except Exception as e:
            print(str(e))
        else:
            thread = threading.Thread(
                target=self.response_handler, args=[res, payload])
            thread.start()

    def changeIP(self):
        with Controller.from_port(port=self.ctrlPort) as controller:
            controller.authenticate(password="")
            controller.signal(Signal.NEWNYM)

    def initTor(self):
        with open(self.torrcPath, 'w') as torrc:
            torrc.write('VirtualAddrNetwork 10.192.0.0/10\n')
            torrc.write('AutomapHostsOnResolve 1\n')
            torrc.write(f'SocksPort {self.torPort}\n')
            torrc.write(f'ControlPort {self.ctrlPort}\n')
            torrc.write('RunAsDaemon 1\n')
            torrc.write('CookieAuthentication 0\n')
        cmd = ['tor', '-f', self.torrcPath]
        try:
            subprocess.check_call(cmd)
        except subprocess.CalledProcessError as e:
            print(f'Error : {str(e)}')
            print('Something went wrong, killing the process')
            pid = os.getpid()
            proc = psutil.Process(pid)
            proc.kill()
